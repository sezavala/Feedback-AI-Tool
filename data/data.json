[
    {
        "id": 1,
        "blog": "Introduction Over the last couple of months, I became a contributor to the freeCodeCamp Classroom app. While working on one of the issues for the project, I witnessed the team-wide consequences of what happens when the codebase has confusing, unreadable code. In this article, I will share a case study that delves into the implications of such code complexities. Not only will I shed light on the challenges we faced, but I will also elucidate the steps we took to overcome them. This journey of discovery and resolution serves as a testament to the significance of maintainable and comprehensible code in any collaborative project.\nThe Codebase / Product\nEvery day, freeCodeCamp empowers a thriving community of 1 million users worldwide on their coding journey. With a remarkable alumni association of 200,000, including professionals employed by renowned giants like Amazon, Microsoft, IBM, and Google, freeCodeCamp serves as a vibrant hub for nurturing technical growth and fostering a supportive global learning community.\n\nThe motivation driving the creation of freeCodeCamp's Classroom mode stems from a genuine desire to cater to the specific needs of teachers. For some time, educators have sought a comprehensive solution to gain a bird's-eye view of their students' progress through freeCodeCamp courses, an innovative and interactive dashboard designed to empower teachers in effortlessly monitoring the progress of multiple freeCodeCamp users across their respective courses. This powerful tool equips educators with real-time insights, enabling them to expertly guide students towards successful learning experiences. Below you will find some screenshots of the MVP in action.\n\n\n\n\nClass Creation: a teacher can create a class and enroll students via an invite link.\n\n\nWith Classroom Mode, teachers can easily create classes and invite students via an enrollment link. They can then gain a comprehensive view of their students' activities and progress via the dashboard.\n\n\n\n\nDashboard: provides a summary of the students’ activity and progress in the class.\n\nExploring the Issue\nThe codebase relied on an outdated JSON schema. The updated JSON schema introduced a distinct structure, differing from the one currently in use. The images below demonstrates the difference in the key/value pairings, as well as how the nested data structure changes.\n\n\n\nOld Schema\nAllows getting data for one certification; the ‘blocks’ object is data pertaining to that one certification.\n\nNew Schema\nAllows for getting data for all certifications; the ‘certifications’ array holds multiple objects which contain certification data. \n\n\nThis newer structure allowed for a teacher to assign multiple certifications to a student, instead of just one. More about how the structure of the JSON schema can be found in this gist.\n\n\n\nWhile this issue did not have an immediate impact on existing functionality. However, postponing the transition to the new JSON schema structure could potentially lead to a more extensive overhaul. Such a delay might necessitate refactoring not only the existing functionality but also any new functionality that would be introduced. Taking prompt action to adopt the updated JSON schema would help mitigate the risk of a larger and more complex restructuring effort in the future.\n\nPerforming substantial code alterations could carry a higher risk of introducing fresh bugs to the codebase. Consequently, it was advantageous to tackle the issue proactively at an earlier stage. Although this approach may not have completely eradicated the possibility of encountering new bugs, it did accelerate their identification, enabling prompt resolution.\nBelow is a flow of control demonstrating how this JSON structure was being utilized.\n\nSystem Overview\nBefore delving into how the issue was solved, let's first examine the project's current functionality. Below, you'll find a system design diagram followed by the tech stack and flow of control that will aid in breaking down the functionality at a higher level.\n\n\nTECH STACK\n\n\nReact\nDisplays the components of the UI, such as the dashboard table.\nNext.js\nServing as a comprehensive full-stack framework, it efficiently manages routing and data fetching. Instead of building out a RESTful API from scratch using something like Express, Next.js allows for dynamic routes which handle parameters that traditionally would have been needed to be extracted. This was effectively used with displaying the correct information based on the user and classroom id.   This technology was utilized for the API processing as well as how the user consumed and interacted with the app (React included).\nPostgreSQL\nStores data such as: classroom information, user (student and teacher) information.\nPrisma\nAn ORM utilized for database interactions.\n\n\nFlow of Control\n\nLet's take a closer look at the flow of control for one example use case for when a teacher views the Classroom dashboard page that summarizes the students’ progress in the course(s).\n\nThe ‘View Class’ button is loaded through the pages/classes/index.js file which renders a React component ‘ClassInviteTable’ where the button logic exists.\n\n\n\n\n\nThe teacher clicks the ‘View Class’ button.\n\n\n\nThe pages/dashboard/[id].js page is loaded, with the classroom ID is passed in through dynamic routing.\n\n\n\n\n\nThe util/api_processor.js file is called. The JSON data is accessed (leveraging Next.js' built-in data fetching) capabilities. As shown in the system design diagram, the endpoint accessed is offered by freeCodeCamp. However, as this endpoint is still under development, a mock server (json-server) is being used, where the endpoint holds the mock data sample which is shown in the ‘Explore the Issue’ section. \n\n\n\nThe JSON data is processed in pages/dashboard/[id].js by calling the fetchStudentData() function in the api_processor.js file.\napi_processor.js\npages/dashboard/[id].js\n\n\n\n\n\nThe mock data ‘studentData’ is passed in as props to the GlobalDashboard component, which renders the UI the teacher sees showing the students’ progress on a course(s).\n\n\n\n\n\nHaving gained insight into the end user's interaction with the functionality, I was able to isolate the segment in the codebase that required updating. I was able to contextualize a solution which consisted of four stages, ultimately leading to a final solution.\nPhase 1: Figuring out where to start\nAs the issue necessitated transitioning the functionality to use the new JSON schema, I had to identify the locations and methods where the JSON schema was being accessed. As shown in the ‘Flow of Control #5,’ this is where the JSON was initially being fetched. I added comments to the processing functions in the api_processor.js file due to the complex logic resulting from the deeply nested data. The comments were successfully merged.\n\n\n\n\nOnce I determined the following:\n\n1. Where the JSON was fetched\n2. How it was parsed\n3. Which React component received the parsed data as props\n\nI was able to obtain a comprehensive understanding of the relevant sections in the codebase requiring changes and proceeded to implement a solution.\nPhase 2: Implementing a solution \nI identified that the GlobalDashboard table component was where the refactor needed to be implemented, the logic of the component existed in components/dashatable_v2.js. I utilized the existing UI logic, and refactored the code to process the new JSON data. There were two places in the file I had to make the changes.\n\n\n\nreactTable hook: an open source library designed to construct tables within the React framework; encompassing JSX, templates, state, styles, and callbacks to create a meaningful datagrid.\nI needed to update the hook so that it used the new JSON data as props.\nconst rawStudentSummary: the value stored in this variable was an object which extracted the data from the JSON (i.e., what courses the student was taken, how many challenges they had completed, and when was the last time they were active).\nThis object’s data was what was used for the reactTable.\n\n\n\n\nA significant portion of the changes occurred in this section of the file. I modified the reactTable and rawStudent summary to accommodate the new JSON schema. Although it might not have been the most efficient solution at the time, my primary focus was to ensure that the issue was addressed and that the code was functional. I submitted my changes for review, and the pull request (PR) was successfully merged. While it did work, its lack of readability meant there was a potential to introduce bugs in certain circumstances (which we will explore in the next phase) this possible outcome made the code fragile.\nPhase 3: Enter Player 2 (Merge Mayhem)\nOnce my changes had gone live another developer synced his fork to match the main branch. Since he was working on the same file as me (he was moving the functionality in its own file, then calling the function in dashtable_v2.js) this naturally led to a merge conflict. Since the logic in both the refactored version and the original version lacked readability, it was difficult to isolate the differences in order to correctly resolve the merge. Below is a visual example of what the comparison looked like.\n The code's lack of readability made it challenging for the developer to grasp how it functioned, leading to the selection of an incorrect version to resolve the conflict. Consequently, after merging the changes into the codebase, the student activity dashboard ended up in a 'broken state.’  This occurred because the dashboard was still relying on the previous functionality, which was designed to work with the old JSON schema. However, the JSON schema had been updated to a new version. As a result, the output for the student name and the processing of the students' progress became inaccurate. The dashboard's appearance was adversely affected as a result of these issues. This resulted in the incorrect output for the student name and the activity and processing of the students’ progress. Note how the left-most column incorrectly shows the text \"email\".  It should instead show the actual email addresses for the students.\n\n\n\nPhase 4: Resolving the Chaos\nTo resolve this issue and prevent similar occurrences in the future, I began by restructuring the dashboard_v2.js file to enhance its readability. As an initial step, I divided the functionality into a separate file. Additionally, I disassembled some of the complex logic into separate functions and abstracted them into a helper file for better organization. This approach also facilitated the partitioning of UI rendering by leveraging React and JSX, enabling the helper functions to render the 'Activity' and 'Progress' columns.\n\nFiguring out the best way to set up the helper functions was not obvious to me and required multiple attempts.  I sought feedback on my first attempt from the project maintainers, and their code review offered a number of improvements to my initial approach. I submitted my second attempt as a separate PR and I am currently awaiting another round of feedback.  \n\n I verified everything worked correctly through snapshot tests which were added by fellow open source contributors which checked that the correct data was being passed into the dashboard. \n\nFinal Solution\nThe changes I made can be found here.  The new dashboard table looks the same on the outside, but it uses the new updated JSON schema instead of the old one.\n\nThe old JSON schema (X’d out) is replaced by the new JSON schema. ",
        "rubric_labels": {
            "section1_project_about": 1,
            "section1_why_important": 1,
            "section1_typical_user": 1,
            "section2_issue_description": 1,
            "section2_issue_importance": 1,
            "section3_tech_stack_description": 1,
            "section3_system_diagram_included": 1,
            "section3_workflow_description": 1,
            "section4_challenges_identified": 1,
            "section4_problem_solving_attempts": 1,
            "section5_solution_explained": 1,
            "section5_solution_testing_proof": 1
        }
    },
    {
        "id": 2,
        "blog": "About the Project\nSonarr is a \"Personal Video Recorder\" for Usenet and BitTorrent users. It's an app that scours the internet or monitors multiple RSS feeds for links to download your desired media. It can scan your media files and check if you're missing any episodes of a particular season of TV shows or Anime, rename them according to an accepted standard or even be configured to automatically download and replace them with a higher desired quality.\nThe app grabs media information from popular database sites like Tvdb and Imdb and uses that information to organize it. This can help users stay up to date on their favorite shows and make it easier to organize them. If set up correctly by the user, it's almost a hands-off maintenance of your media files. And it’s not just for personal use, if you host a large media server that many people have access to, or you provide a service to, this should provide the host with less headaches. A quality-of-life app for these users with a large media library that they would want to manage.\nExample usage:\n1.) Homepage: localhost:8989 (since I’m using this as a personal use app)\n\n2.) Media page.\n\n3.) Searching for results. If searching for a season, it can take a while as it’s searching for each episode as well as the season packs.\n\n4.) Search results. Or just one result for this series. Here, it took me about 5 minutes to produce the results.\n\n\n5.) Click the button on the right to start the download. Provided that you set up Sonarr correctly, the app will initialize the download with your favorite torrent app.\nThe Issue\nAnime Standard Format Search (allow search by seasons) #5616. For some indexers, with the option of “Anime Standard Format Search” on, season packs for anime will not show up. For indexers that are reasonably competent or specialized in the Anime category, this is not a problem, season packs do show up. The issue arises for indexers that are more general in content (but still have some anime), season packs will not show up for anime search queries.\nThis is a quality-of-life issue, and QOL patches are always welcomed, never scorned. Our patch can make Sonarr easier and more user-friendly for Anime fans. This is just an overall improvement on the user experience with this app, increasing the user base.\nWhere to start:\nHere is the issue we’re trying to fix. Let us search for the Anime, One Punch Man, season 1. These are the results before our changes.\n\nTo peek into the future, before explaining the final solution, these are the results after our changes. We’re able to get 4 additional results that are valid.\n\nThrough the search feature of the IDE, we were able to find some functions related to the “anime” query in several files. Then we found an object called AnimeEpisodeSearchCriteria. Then we used the search function again for said object. A couple of functions stood out to us.\n\nThe function shown above was found in the file, ReleaseSearchService.cs. While exploring the file, just a bit below the function SearchAnime, there was SearchAnimeSeason.\n\nCodebase Overview\nTech Stacks:\n\nSystem diagram:\n\nFlow of Control:\n1.) We’ll start with the homepage shown here.\n\n2.) Let’s look at One Punch Man’s media page.\n\n3.) When that button is clicked, an app call is made by the front-end. That call is then received by the back-end, which analyzes the request. Eventually, it reaches here, the function SearchAnimeSeason(), called in the ReleaseSearchService.cs file.\n\nJudging from its code, it just searches for every episode in the season, no specific season pack search.\n4.) With the function above, it will identify what indexer Sonarr is using, and eventually reach this function, GetSearchRequests().\n\nFrom the SearchAnimeSeason function, the GetSearchRequests function is called for each episode.\n5.) After the functions have finished running, we’ll get our search results for One Punch Man here.\n\nChallenges\nOne of the technical challenges we faced was finding a good way to test our code changes. Previously, when we were just confirming the, at the time, the current behavior of the app, we found no difference when the “Anime Standard Format Search” option was on or off.\nSince the issue was not getting season packs for anime, we assumed that when searching for individual episodes, the desired behavior was for season packs to show up as well that contained that individual episode. Another possible solution that we thought of was when a full season search is performed, on the first episode, look for season packs as well. Lastly, we had the idea to add another episode to search for that episode object that would have all the same parameters as the first episode, but instead only search for the season packs, ignoring any mention of the first “episode”.\nI made inquiries with the project maintainer about it, and it turns out that none of those was the desired solution. Referring to our first assumption, the indexer that we were using to test search results was too capable of an Anime indexer. He suggested using Prowlarr, another project from the same developers of Sonarr, to add generic, general content indexers. As for our second assumption, the project maintainer wanted a separate search done, not pairing it with the first episode search. That leads to our third assumption. While we were able to do a separate search, we were still using the “AnimeEpisodeSearchCriteria” object, but the project maintainer wanted a separate object to conduct the season search called “AnimeSeasonSearchCriteria” instead. After all those inquiries about the desired solution, we finally came to our final solution.\nFirst attempt:\nWe made only one code change here, and that was to search for season packs on every episode.\n\nHere’s the console of what’s going on for our first attempt. First, let’s look at the original behavior in the console before we started working on the issue.\n\nNow here, we saw our changes working, only, it’s working too much.\n\nSecond attempt, trying to search only once:\nTo make it so that we only search for season packs only once, we needed to add a flag in the existing object, “AnimeEpisodeSearchCriteria”.\n\nThen we use that flag to detect the first episode.\n\n\nWith that flag, we made it so that when the searchCriteria object is on its first episode, run a season search.\n\nHere’s the console for our second attempt.\n\nThird attempt:\nWe kept the flags, we added a new fake episode, and on that episode, GetSearchRequest() will only do a season pack search.\n\nOf course, to make it only search for seasons on that first “fake” episode, it took some finagling.\n\nFinally, here’s our console for our “failed” results. We got the desired results, it’s just not the best practice.\n\nSolution\nAs I have shown above, the previous solutions were all just quick fixes that weren't readable at first glance. More of a bandaid than a cure. With some communication from the project maintainer, it was more important to introduce a new object called “AnimeSeasonSearchCriteria”. This increases code reusability, scalability, and readability. These are just some of the important aspects to have in any project.\nDue to the journey of our challenges, we were at least familiar with what we needed to do. There’s already the object “AnimeEpisodeSearchCriteria” that exists. Following the same pattern, we made the object “AnimeSeasonSearchCriteria”, a sibling class. Compared to the episode variant, our new object only has one crucial data container, the season number. The episode variant had more data stored, like episode number, which is unnecessary for our goal.\nTo do that, we needed to add a file for it in this folder:\n\nIn the folder, /Core/IndexerSearch/Definitions/, we added the file, AnimeSeasonSearchCriteria.cs, which contains our new object.\n\nThe “AnimeEpisodeSearchCriteria” for reference.\n\nSo here is our new object class.\n\nEven though this new object only holds one piece of data, making a new object like this improves scalability if the project may want to improve or add more features to the season search.\nWith our new object created, we’re ready to implement it throughout the codebase. Wherever there’s an object of “AnimeEpisodeSearchCriteria” being used, we’ll make another function below it using our new object, “AnimeSeasonSearchCriteria”, taking cues of patterns from the episode search function into making a new function. We had to edit 21 files, so I’ll only just give 2 examples below.\nExample 1:\nHere, in a file that handles a specific indexer’s search API, NyaaRequestGenerator.cs, this is one use of the “AnimeEpisodeSearchCriteria” object.\n\nLuckily, since C# is written similarly to C++, it’s easy to know the different parts of the function using the object. So writing a function for our new object proved to be not that difficult. Compared to the function above, here we just copied the same pattern for our new function, it’s the same code but all instances of anything related to “episode” are removed.\n\nExample 2:\nAnother indexer called “FileListRequestGenerator.cs\".\n\nThen for our new object, here’s our new function right below it.\n\nWe just removed all instances of “episode”.\nOverall, for our new object, “AnimeSeasonSearchCriteria”, we would just take the same logic used for “AnimeEpisodeSearchCriteria” objects, and implement it in a new function right below in the same file.\nHere’s the console that shows off the new object.\n\nNow that the first search for season packs is appropriately labeled.\nThe result of our work, and the results of a search query:\nWith this option off in the indexer settings.\n\nWe get these results.\n\nThen with this option on.\n\nWe get these results after changes.\n\nWe’ve successfully made a positive change and got 4 more relevant results. After some testing, and writing some new tests, our work was approved and merged with the main project.\nLink(s):\nOur pull request, merged.",
        "rubric_labels": {
            "section1_project_about": 1,
            "section1_why_important": 1,
            "section1_typical_user": 1,
            "section2_issue_description": 1,
            "section2_issue_importance": 1,
            "section3_tech_stack_description": 1,
            "section3_system_diagram_included": 1,
            "section3_workflow_description": 1,
            "section4_challenges_identified": 1,
            "section4_problem_solving_attempts": 1,
            "section5_solution_explained": 1,
            "section5_solution_testing_proof": 1
        }
    }
]